# Pattern Composer

This program enables the creation of music simulations based on user-defined code, which are then output as MIDI files. It allows for high-level definitions of songs including key, chord progression, parts and patterns in a user-friendly JSON format.

# Quickstart Guide

## Requirements
This application requires Python 3.10. If you don't have Python installed, please visit the 
[official Python website](https://www.python.org/) to download and install the latest version.

## Getting Started
The application comes with a sample multitrack arrangement of the song "Kids" by MGMT. This example should help you understand the various features of the application.

Here's how you can run the sample arrangement:

Navigate to the root directory of the application using your terminal or command prompt. This is where the composer.py file is located.

In the terminal or command prompt, type the following command to run the application with the "Kids" arrangement:

```bash 
python composer.py kids.json
```
Press Enter to execute the command. The program will take a few seconds to complete the simulation and generate the MIDI file.

# Digital Audio Workstation (DAW) Compatibility and Recommendations
The program generates a MIDI file, which can be imported into a Digital Audio Workstation (DAW) of your choice. The MIDI files have been tested with GarageBand and Ableton Live, and have shown successful results.

## How to Integrate MIDI files with your DAW
Note that the program does not directly integrate with DAWs. To use the MIDI file with your DAW, follow the steps below:

### Run the program to generate a MIDI file.
Locate the generated MIDI file (in the program's output folder).
Drag and drop, or import the MIDI file into your DAW.
Unfortunately, most DAWs don't support automatic reloading of MIDI files. Each time the program generates a new MIDI file, you'll have to manually import it into your DAW.

### Tips for Ableton Live Users
For Ableton Live users, here's a quick tip to streamline your workflow:

Click on 'Add Folder' in the left-side menu of Ableton Live.
Navigate to and select the output folder of the program.
Any MIDI files generated by the program will now automatically appear in this folder within Ableton Live.
Note on File Names

Currently, the program adds a date and timestamp to the name of each generated MIDI file. I'll add an option for overwriting it (same name) if this is something you want as a feature. This could be beneficial for those who figure out a way to have their DAW automatically reload MIDI files. Updates regarding this feature will be provided as they become available.


# Practical Information
## Internet Connection
This program requires an active internet connection to function correctly.

## Feedback and Suggestions
I highly appreciate your feedback and suggestions. If you encounter any issues or have ideas for improvements, feel free to leave a comment in the issues section of the repository. I'm eager to hear your thoughts and experiences, and I will consider every suggestion. I have a low threshold for implementing changes that will enhance the functionality and user experience of the program.

[Go to Issues](https://github.com/keychange/Pattern-Composer/issues)

## Stay Updated
Want to stay informed about the program's progress? If you're interested in receiving updates about new features or bug fixes, consider subscribing to my email list. Just follow the link below to sign up:

[Subscribe to our Email List](https://docs.google.com/forms/d/1-xlsBSfBegOmXaXVDwhEFMPwyxnEi7PEey8UV2GpWr4/viewform?edit_requested=true#responses)

## Contact

If you have any questions, feedback, or suggestions, please don't hesitate to get in touch. You can reach me at the following email address:

key.change.inquiry@gmail.com

# Documentation

## Arrangements
The arrangements for a song are defined in a JSON file located in the /arrangements directory at the top level. This includes the overarching details of the song, such as the musical key, the chord progressions, and the sequences, as well as the instances of various musical patterns that will be used in the song.

The instances refer to Python classes that define different patterns. These classes can be found in the /patterns folder, and they must inherit from the interfaces.Pattern class, which is defined in interfaces.py at the top level. The classes in the patterns folder are imported recursively, which allows for the use of subfolders within it.

## Patterns
The classes in the /patterns folder define the music patterns for the song. Each pattern is defined in a class that inherits from the Pattern class, defined in interfaces.py. This class includes various methods that are used to create the musical patterns and to interact with the arrangement.

## Pattern Classes
An example of a pattern class is the KidsDrums class:


```python
from interfaces import Pattern
from utils.functions import repeat_until_done
from utils.constants import *

class KidsDrums(Pattern):

    def __init__(self):
        self.bridge_toms_pause_switch = True
        self.standard_parts = [
            'intro', 
            'intro2',
            'verse', 
            'chorus', 
            'chorus2', 
            'bridge'
        ]

        self.clap_parts = [
            'intro2', 
            'chorus', 
            'chorus2', 
            'bridge'
        ]

    @repeat_until_done(0.125)
    def run(self):
        if any([self.is_part(part) for part in self.standard_parts]):
            self.standard()
            if self.get_cursor().bar % 8 == 7:
                self.transition()
            
        if any([self.is_part(part) for part in self.clap_parts]):
            self.claps()

        if self.is_part('verse2'):
            bar = self.get_cursor().bar
            if 4 <= bar < 12:
                self.syncopated()
            if 12 <= bar < 15:
                self.eight_notes()
            if self.get_cursor().bar == 15:
                self.second_transition()

        if self.is_part('bridge'):
            self.bridge_toms()

    def standard(self):
        if self.get_cursor().quarter_notes in [0,2]:
            self.play(BASS_DRUM, release=0.5, velocity=100)
        if self.get_cursor().quarter_notes in [1,3]: 
            self.play(ACOUSTIC_SNARE, release=0.5, velocity=100)

    def syncopated(self):
        if self.get_cursor().eight_notes in [0, 3, 4]:
            self.play(BASS_DRUM, release=0.5, velocity=100)

    def eight_notes(self):
        if self.get_cursor().quarter_notes in range(4):
            self.play(BASS_DRUM, release=0.5, velocity=100)

    def claps(self):
        if self.get_cursor().quarter_notes in [1,3]:
            self.play(HAND_CLAP, release=0.5, velocity=100)
    
    def bridge_toms(self):
        eight_notes = self.get_cursor().eight_notes
        bar = self.get_cursor().bar
        if eight_notes in range(0,4) or eight_notes in [4,6]:
            self.play(LOW_TOM, release=0.5, velocity=100)
        if self.bridge_toms_pause_switch and eight_notes == 5:
            self.play(LOW_TOM, release=0.5, velocity=100)
        if self.is_beginning_of_bar():
            self.bridge_toms_pause_switch = not self.bridge_toms_pause_switch
    
    def transition(self):
        if self.get_cursor().sixteenth_notes == 7:
            self.play(ACOUSTIC_SNARE, release=0.5, velocity=100)
        if self.get_cursor().eight_notes in [5, 6]:
            self.play(HAND_CLAP, release=0.5, velocity=100)

    def second_transition(self):
        if (self.get_cursor().sixteenth_notes in [7, 10] 
            or self.get_cursor().quarter_notes in [0,1,2]):
            self.play(BASS_DRUM, release=0.5, velocity=100)
        if self.get_cursor().sixteenth_notes in [12, 15]:
            self.play([HAND_CLAP, ACOUSTIC_SNARE], release=0.5, velocity=100)
            
````


## The Run Method
The run method is an essential part of each pattern class. This method, which must be overridden in each pattern class, is called at the beginning of each part where the pattern is included. By using the decorator `@repeat_until_done(duration)`, you can have the run method be repeated for the duration of the part. The duration is specified in terms of notes, with 1 being a quarter note.

## Determining the Current Part
The `self.is_part(part)` method can be used to check which part of the song is currently being played.

## Timing
The `self.get_cursor()` method provides a datetime-like object that can be used to determine the current position within the part. This object has several properties including bar, half_notes, quarter_notes, eight_notes, sixteenth_notes, and thirtytwo_notes. The `self.is_beginning_of_bar()` method can be used to check if the current position is at the exact beginning of a bar.

## Playing Notes
The `self.play()` method is used to play notes. For drums, the arguments can include constants that represent specific drum sounds (e.g., BASS_DRUM). These constants map to specific keys on a piano and are defined in utils/constants.py. The release argument specifies the duration of the note, with 1 equaling a quarter note. The velocity argument specifies the speed of the key press, following the MIDI protocol, and can range from 0 to 127.

## Bass Line Pattern
The KidsBass class is a pattern class that defines a bass line for a song. This class introduces additional methods and ways of interacting with the song and the chord progression.

```python
from interfaces import Pattern
from utils.functions import repeat_until_done
from utils.constants import *
from utils.functions import get_close_to_frequency

class KidsBass(Pattern):

    def __init__(self):
        step = self.get_current_chord().get_notes(octave=1)[0].step
        key = self.get_key()
        self.root = get_close_to_frequency('G#0', step, key)
    
    def on_chord_change(self, chord):
        chord_notes = chord.get_notes(octave=0)
        key = self.get_key()
        self.root = get_close_to_frequency('G#0', chord_notes[0].step, key)

    @repeat_until_done()
    def run(self):
        if self.is_part('verse2') and self.get_cursor().bar < 8:
            self.drawn_out()
        elif self.is_part('verse2') and self.get_cursor().bar >= 8:
            self.build_up()
        else:
            self.pulse()

    def pulse(self):
        self.play(self.root, release=0.5, velocity=100)
        self.sleep(0.5)
        self.play(self.root+12, release=0.5, velocity=100)
        self.sleep(0.5)

    def drawn_out(self):
        self.play(self.root, release=4, velocity=100)
        self.sleep(4)

    def build_up(self):
        self.play(self.root, release=1.5, velocity=100)
        self.sleep(1.5)
        self.play(self.root+12, release=2.5, velocity=100)
        self.sleep(2.5)

```
## Pattern Initialization and Chord Changes
The __init__ method is used to set up initial state for a pattern. In the KidsBass class, this method is used to set the root note of the bass line based on the step of the first note of the current chord in the first octave.

```python
def __init__(self):
    step = self.get_current_chord().get_notes(octave=1)[0].step
    key = self.get_key()
    self.root = get_close_to_frequency('G#0', step, key)
```
The `on_chord_change` method is called every time the chord changes in the song. This allows you to update the state of the pattern based on the new chord. In the KidsBass class, this method updates the root note of the bass line.

```python
def on_chord_change(self, chord):
    chord_notes = chord.get_notes(octave=0)
    key = self.get_key()
    self.root = get_close_to_frequency('G#0', chord_notes[0].step, key)
```

## Note Objects
In addition to integer values representing specific keys on a piano, the play method can also accept Note objects. The Note class includes properties like step and octave. The step is the chromatic offset from the key of the song.

For instance, when playing the bass line, a Note object representing the root note is passed to the play method:

```python
self.play(self.root, release=0.5, velocity=100)
```
In this case, self.root is a Note object.


## The Sleep Method and Time Progression
Patterns often include rhythmic elements and will need to pause or "sleep" for a certain amount of time to achieve the desired musical effect. The `self.sleep()` method is used for this purpose.

In the KidsBass class, for example, the `sleep()` method is used to pause the execution of the pattern, thereby creating a rhythmic bass line:

```python
def pulse(self):
    self.play(self.root, release=0.5, velocity=100)
    self.sleep(0.5)
    self.play(self.root+12, release=0.5, velocity=100)
    self.sleep(0.5)
```
The `self.sleep()` method moves the execution timeline forward by the amount specified by its argument. The argument to `self.sleep()` follows the same musical note duration convention used throughout the library, with 1 representing a quarter note.

The use of the `self.sleep()` method is particularly important when using the `repeat_until_done()` decorator without a pause value argument. If no pause value is supplied, the decorated function will be executed continuously in an infinite loop. In these cases, `self.sleep()` must be used within the decorated function to advance the execution timeline and prevent the infinite loop.

## The Thread Decorator for Time Management
In addition to the `repeat_until_done()` decorator, the library provides the `@thread()` decorator to assist with time management in your patterns. The `@thread()` decorator allows you to temporarily advance the timeline while playing notes, and then return to the original point in time, keeping the notes that were played.

This feature is especially useful when you want to play certain motifs at specific points in time without having to worry about aligning with bars or missing certain timing markers. By using the `@thread()` decorator, you can ensure accurate timing when combined with the `repeat_until_done(0.125)` decorator, for example.

Here's an example of how the `@thread()` decorator is used in the KidsMelody class:

```python
from interfaces import Pattern
from interfaces import Chord
from utils.functions import repeat_until_done
from utils.constants import *
from utils.functions import get_close_to_frequency
from utils.functions import thread

class KidsOtherMelody(Pattern):

    def __init__(self):
        self.velocity=60
        self.on_chord_change(self.get_current_chord())

    @repeat_until_done(0.125)
    def run(self):
        if self.is_part('verse') and self.get_cursor().bar < 8:
            return
        self.play_melody()

    def on_chord_change(self, chord):
        root, third, fifth = chord.get_notes(octave=2)

        self.first_motif = [
            [root, root, third, third, root, root, third, root, third.get_next(), fifth],
            [1, 1.5, 1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5]
        ]
        self.second_motif = [
            [root, root.get_next(), root, third, root.get_next(), root, root.get_previous(mode=chord.quality)],
            [1, 0.5, 1, 0.5, 0.5, 0.5, 0.5]
        ]
        self.third_motif = [
            [third.get_next(2), third.get_next(), root.get_previous(mode=chord.quality), root.get_next(1), third, root.get_next(1), root],
            [0.5]*3+[1]+[0.5]*3
        ]
    
    def play_melody(self):
        if self.is_beginning_of_bar():
            if self.get_cursor().bar % 4 == 0:
                self.standard_motif(self.first_motif)
            if self.get_cursor().bar % 4 == 3:
                if (self.get_cursor().bar // 4) % 2 == 0:
                    self.offset_motif(self.second_motif)
                else:
                    self.standard_motif(self.third_motif)

    @thread()
    def standard_motif(self, motif):
        self.play_notes(motif)

    @thread(offset=-0.5, chord_offset=False)
    def offset_motif(self, motif):
        self.play_notes(motif)

    def play_notes(self, motif):
        for note, pause in zip(*motif):
            self.play(note, release=self.get_pause(pause), velocity=self.velocity)
            self.sleep(pause)

    def get_pause(self, pause):
        return 0.75*pause if pause > 0.75 else pause
```
The `@thread()` decorator takes two optional arguments: `offset` and `chord_offset`.

`offset`: This argument specifies the start time, in quarter notes, from when the threaded motif is called. It allows you to control when the threaded motif starts playing relative to the timeline.

`chord_offset`: This argument indicates whether you want the current chord to be offset as well. This is useful when you want to refer to the chord that would have been playing if the time hadn't been offset.

By using these decorators and methods, you can create complex musical patterns that adapt to the chord progression, key of the song, and various timing constraints.

## Methods for Modulating Note Objects
The library provides methods to manipulate Note objects within a musical pattern. These methods allow you to move up or down the scale, in any given scale, and by specific steps.

The `get_next()` and `get_previous()` methods can be used on Note objects to return Note objects higher or lower, respectively.

```python
get_next(steps: int, mode: str)
get_previous(steps: int, mode: str)
```
`steps`: This parameter defines the number of steps to move. For example, `steps=2` would move two steps up or down the scale.

`mode`: This parameter determines the scale to use when moving. By default, these methods use the diatonic scale. However, you can specify any mode defined in the SCALES or CHORDS in utils/constants.py

For example:

```python
new_note = tmp_note.get_next(steps=2, mode='chromatic')
```
In this case, get_next() is used to select the second next note from the chromatic scale.

These methods are used extensively in the KidsSolo class to create complex solo lines that follow the chord changes and key of the song.

## Creating Scales and Chords
The Chord class in the program can be used to create scales as well as chords, given that both are essentially sequences of intervals starting from a particular note.

For instance, the Chord class is used to create the pentatonic scale in the KidsMelody pattern class.

```python
notes = Chord(1, 'pentatonic').get_notes(octave=3)
```
In this case, the Chord object is initiated with arguments 1 and 'pentatonic', where 1 represents the first step in the key of the song and 'pentatonic' is the name of the scale.

## Getting Notes from a Chord or Scale
The Chord class itself does not hold explicit information about the concrete notes of the scale or chord. However, you can obtain a list of Note objects representing the actual notes of the scale or chord by calling the `.get_notes()` method on the Chord object.

The `.get_notes()` method takes an argument specifying the octave for the notes. For example, in the KidsMelody pattern class, the pentatonic scale is obtained in the third octave:

```python
notes = Chord(1, 'pentatonic').get_notes(octave=3)
````


This results in a list of Note objects, notes, that represent the notes of the pentatonic scale in the third octave.


# Arrangement Documentation
## Overview
An arrangement of a song is defined in a JSON file that includes "key", "instances", "sequences", and "progressions".

## Key
The key field denotes the key in which the song is played.

## Instances
The instances field contains instances of pattern classes that will be used in the song, with the class name and any parameters to be passed to the class constructor. Each instance is represented as a key-value pair where the key is the instance name and the value is another key-value pair that includes the "class" name and "params".

Here's an example:

```json
"instances": {
    "drums": {
        "class": "KidsDrums",
        "params": {}
    },
    "bass": {
        "class": "KidsBass",
        "params": {}
    },
}
````

In this case, "drums" and "bass" are instances of the KidsDrums and KidsBass classes, respectively. Each of these classes are instantiated with no parameters (`"params": {}`).

If you need to pass parameters to the constructor of the class, you can do this by creating a dictionary where the key is the parameter name and the value is the desired value, as long as the value can be represented using standard JSON.

## Sequences
In the "sequences" field, each key represents a distinct section of the song such as the "intro", "verse", "chorus", and so on. The value associated with each key is a list that defines the simultaneous playback of multiple tracks during that section.

The list contains instance names from the "instances" field, which are references to specific sound or instrument patterns. The order of these instance names within the list corresponds to different tracks, and all instances will play simultaneously.

For example, with the following sequence definition:

```json
"sequences": {
    "intro": ["drums", "None", "melody"],
    "verse": ["drums", "bass", "None", "other_melody", "None"]
}
```
During the "intro" section, three tracks will play at the same time: the first track plays the "drums" instance, the second track is silent (represented by "None"), and the third track plays the "melody" instance.

Similarly, during the "verse" section, five tracks will play simultaneously: the first track plays the "drums" instance, the second track plays the "bass" instance, the third track is silent, the fourth track plays the "other_melody" instance, and the fifth track is silent.

In this context, "None" represents a silent track, meaning no instance will play on that particular track during the defined section. This allows for dynamic instrumentation where certain tracks can be silent during some parts of the song while playing an instance during other parts.

## Progressions
The progressions field defines a list of chord progressions for different parts of the song. Each progression is represented as an object with the following properties:

"name": the name of the part of the song

"time_signature": the time signature of the part, represented as a two-element array (e.g., [4,4] for 4/4 time)

"chords": an object that defines the chord progression for the part
The "chords" object contains the following properties:

"repetitions": the number of times the chord progression should be repeated

"sequence": a list of chords that make up the progression
Each chord in the sequence is represented as a list with the following elements:

A chromatic offset from the first step of the scale (starting at 1, so 1 is the first step in the key)
The quality of the chord (e.g., "major" or "minor")
The number of quarter notes for which the chord should be played
(optional) The inversion of the chord, represented as an integer. If this value is present and is 1, the first inversion is used. For example, if you call .get_notes on a chord object holding a triad with a first inversion, you will get the third, then the fifth, and then the root above that.
Here's an example:

```json
"progressions": [
    {
        "name": "intro",
        "time_signature": [4,4],
        "chords": {
            "repetitions": 2,
            "sequence": [
                [10, "minor", 4],
                [6, "major", 4],
                [1, "major", 4],
                [8, "major", 4]
            ]
        }
    }
]
```
In this case, during the "intro" part of the song, a chord progression is played that consists of a Dm (10th step, minor, 4 quarter notes), F (6th step, major, 4 quarter notes), A (1st step, major, 4 quarter notes), and C (8th step, major, 4 quarter notes). This progression is repeated twice.

